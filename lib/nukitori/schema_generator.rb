# frozen_string_literal: true

require 'json'

module Nukitori
  class SchemaGenerator
    attr_reader :model

    # @param model [String, nil] LLM model to use
    # @param block [Proc] Schema definition block
    #
    # @example
    #   generator = Nukitori::SchemaGenerator.new do
    #     array :repos do
    #       object do
    #         string :name
    #         string :url
    #       end
    #     end
    #   end
    #
    def initialize(model: nil, &block)
      raise ArgumentError, 'Block required for schema definition' unless block_given?

      @model = model
      @schema_block = block
    end

    # Create extraction schema for given HTML
    # @param html [String, Nokogiri::HTML::Document] HTML string or Nokogiri document
    # @return [Hash] Generated extraction schema
    #
    # @example
    #   extraction_schema = generator.create_extraction_schema_for(html)
    #
    def create_extraction_schema_for(html)
      doc = html.is_a?(Nokogiri::HTML::Document) ? html : Nokogiri::HTML(html)
      requirements = build_requirements(&@schema_block)
      processed_html = HtmlPreprocessor.process(doc)
      normalized_requirements = normalize_requirements(requirements)
      prompt = build_prompt(normalized_requirements)

      chat = ChatFactory.create(model:)
      chat.with_instructions(prompt)

      response = chat.ask(processed_html)
      ResponseParser.parse(response.content)
    end

    private

    def build_requirements(&block)
      schema_class = Class.new(RubyLLM::Schema, &block)
      schema_class.new.to_json
    end

    def normalize_requirements(requirements)
      schema_json = JSON.parse(requirements)
      schema_json.dig('schema', 'properties')
    end

    def build_prompt(requirements)
      <<~PROMPT
        You are an expert at analyzing HTML structure and generating XPath expressions.

        ## Task
        Analyze the provided HTML and generate an XPath schema that can extract data
        matching the requirements schema below. Return ONLY valid JSON, no other text.

        ## Requirements Schema (what to extract)
        ```json
        #{requirements.to_json}
        ```

        ## XPath Schema Format

        For each field in requirements, generate the corresponding XPath definition:

        1. **For primitive types** (string, integer, number, boolean):
           ```json
           {
             "field_name": {
               "xpath": "//div[@class='example']",
               "type": "string"
             }
           }
           ```

        2. **For arrays of objects**:
           ```json
           {
             "items_list": {
               "type": "array",
               "container_xpath": "//div[@class='item']",
               "items": {
                 "name": {"xpath": ".//h3", "type": "string"},
                 "price": {"xpath": ".//span[@class='price']", "type": "number"}
               }
             }
           }
           ```

        3. **For arrays of strings**:
           ```json
           {
             "tags": {
               "type": "array",
               "container_xpath": ".//a[@class='tag']",
               "items": {
                 "xpath": ".",
                 "type": "string"
               }
             }
           }
           ```

        ## XPath Rules

        - Use `container_xpath` to identify repeating elements for arrays
        - Use relative XPaths (starting with `.//` or `.`) for fields inside arrays
        - Do NOT use `/text()` - just select the element, we extract text automatically
        - Use `@attr` to extract attribute values (e.g., `@href`, `@src`), especially for schema attributes which ends at `link` or `url`
        - Prefer semantic attributes: `@data-testid`, `@role`, `@aria-label`
        - Prefer tag structure: `//article//h3/a` over class-based selectors

        ## CRITICAL: Avoid Page-Specific Values

        The XPath schema must work on ALL similar pages, not just this one. NEVER use:

        - **IDs with numbers/UUIDs**: `@id='product-price-19140'` or `@id='item-abc123'` — these are page-specific
        - **Dynamic function names**: `@x-data='initComponent_6956666703fbc()'` — these change per page load
        - **Hashed class names**: `Box-sc-62in7e-0`, `css-1a2b3c`, `styled-xyz123` — generated by CSS-in-JS
        - **Session/random tokens**: any attribute value that looks like a hash or random string

        Instead, use:
        - Class names that describe purpose: `@class='price'`, `@class='product-title'`
        - Structural patterns: `//div[@class='product']//span[contains(@class,'price')]`
        - Partial matches when needed: `contains(@id,'product-price')` instead of exact ID
        - Tag hierarchy: `//article//h3/a` — relies on structure, not dynamic values

        ## Output

        Return ONLY the JSON XPath schema. No explanations, no markdown code blocks.
      PROMPT
    end
  end
end
